import numpy as np
from math import *
import os
from numba import jit,njit
from numba import cuda


"""os"""
def creat_path(path):
    if not os.path.exists(path):
        os.makedirs(path)
def distance_3d(p1,p2):
    d=p1-p2
    return sqrt(d.dot(d))

@cuda.jit(device=True)
def CUDA_distance_3d(p1,p2):
    dx=p1[0]-p2[0]
    dy=p1[1]-p2[1]
    dz=p1[2]-p2[2]
    return sqrt(dx*dx+dy*dy+dz*dz)
@cuda.jit(device=True)
def CUDA_subtraction_3d(t1,t2):
    return (t1[0] - t2[0], t1[1] - t2[1], t1[2] - t2[2])
@cuda.jit(device=True)
def CUDA_subtraction_3d_scalar(t1,t2):
    return (t1[0] - t2, t1[1] - t2, t1[2] - t2)
@cuda.jit(device=True)
def CUDA_addition_3d(t1,t2):
    return (t1[0] + t2[0], t1[1] + t2[1], t1[2] + t2[2])
@cuda.jit(device=True)
def CUDA_addition_3d_scalar(t1,t2):
    return (t1[0] + t2, t1[1] + t2, t1[2] + t2)

@cuda.jit(device=True)
def CUDA_division_3d(t1,t2):
    return (t1[0] / t2[0], t1[1] / t2[1], t1[2] / t2[2])
@cuda.jit(device=True)
def CUDA_division_3d_scalar(t1,t2):
    return (t1[0] / t2, t1[1] / t2, t1[2] / t2)
@cuda.jit(device=True)
def CUDA_multiplication_3d(t1,t2):
    return (t1[0] * t2[0], t1[1] * t2[1], t1[2] * t2[2])
@cuda.jit(device=True)
def CUDA_multiplication_3d_scalar(t1,t2):
    return (t1[0] * t2, t1[1] * t2, t1[2] * t2)

'''2d'''
@cuda.jit(device=True)
def CUDA_subtraction_2d(t1,t2):
    return (t1[0] - t2[0], t1[1] - t2[1])
@cuda.jit(device=True)
def CUDA_subtraction_2d_scalar(t1,t2):
    return (t1[0] - t2, t1[1] - t2)
@cuda.jit(device=True)
def CUDA_addition_2d(t1,t2):
    return (t1[0] + t2[0], t1[1] + t2[1])
@cuda.jit(device=True)
def CUDA_addition_2d_scalar(t1,t2):
    return (t1[0] + t2, t1[1] + t2)

@cuda.jit(device=True)
def CUDA_division_2d(t1,t2):
    return (t1[0] / t2[0], t1[1] / t2[1])
@cuda.jit(device=True)
def CUDA_division_2d_scalar(t1,t2):
    return (t1[0] / t2, t1[1] / t2)
@cuda.jit(device=True)
def CUDA_multiplication_2d(t1,t2):
    return (t1[0] * t2[0], t1[1] * t2[1])
@cuda.jit(device=True)
def CUDA_multiplication_2d_scalar(t1,t2):
    return (t1[0] * t2, t1[1] * t2)
@cuda.jit(device=True)
def to_tuple_3d(v):
    return (v[0],v[1],v[2])

@cuda.jit(device=True)
def to_tuple_2d(v):
    return (v[0], v[1])

@cuda.jit(device=True)
def CUDA_cross_3d(v1,v2):
    x1=v1[0]
    y1 = v1[1]
    z1 = v1[2]
    x2 = v2[0]
    y2 = v2[1]
    z2 = v2[2]
    x=y1*z2-y2*z1
    y=-(x1*z2-x2*z1)
    z=x1*y2-x2*y1
    return (x,y,z)
@cuda.jit(device=True)
def CUDA_dot_3d(v1,v2):
    return v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2]


@cuda.jit(device=True)
def CUDA_3d_length(v):
    return sqrt(CUDA_dot_3d(v,v))

@cuda.jit(device=True)
def CUDA_normalize_3d(v):
    l=CUDA_3d_length(v)
    return (v[0]/l,v[1]/l,v[2]/l)

def distance(p1,p2):
    d=p1-p2
    return sqrt(d.dot(d))



def normlize_vector(v):
    l=sqrt(v.dot(v.transpose()))
    assert l>0
    return v/l

@cuda.jit(device=True)
def CUDA_get_3d_line_plane_cross(plane_para,line_para):
    '''plane_para: np.array([a,b,c,x1,y1,z1]) a(x-x1)+b(y-y1)+c(z-z1)=0
       line_para:  np.array([d,e,f,x2,y2,z2]) (x-x2)/d=(y-y2)/e=(z-z2)/f'''
    a=plane_para[0]
    b=plane_para[1]
    c=plane_para[2]
    x1=plane_para[3]
    y1=plane_para[4]
    z1=plane_para[5]
    d = line_para[0]
    e = line_para[1]
    f = line_para[2]
    x2 = line_para[3]
    y2 = line_para[4]
    z2 = line_para[5]
    vpt = d * a + e * b +f * c
    if vpt==0:
        return (x2,y2,z2),0.0
    t=((x1 - x2) * a + (y1 - y2) * b + (z1 - z2) * c) / vpt
    return (x2+t*d,y2+t*e,z2+t*f),t


'''read txt pointcloud'''
def read_txt_pointcloud(filename,COLOR_FLAG=False):
    f=open(filename,'r')
    lines=f.readlines()
    f.close()
    if COLOR_FLAG:
        pc_array=np.zeros([len(lines),6])
        for i in range(len(lines)):
            temp=lines[i].split(' ')
            for n in range(6):
                pc_array[i][n]=float(temp[n])
    else:
        pc_array = np.zeros([len(lines), 3])
        for i in range(len(lines)):
            temp = lines[i].split(' ')
            for n in range(3):
                pc_array[i][n] = float(temp[n])
    return pc_array

def save_general_obj(filename,vs,f_vs):
    f = open(filename, 'w+')
    line = '# generated by WX with python-3.9 in'
    import datetime
    line += datetime.datetime.today().ctime()
    f.write(line + '\n')
    # write vertex
    for i in range(vs.shape[0]):
        x_str = str(round(vs[i, 0], 3))
        y_str = str(round(vs[i, 1], 3))
        z_str = str(round(vs[i, 2], 3))
        line = 'v ' + x_str + ' ' + y_str + ' ' + z_str + '\n'
        f.write(line)


    for i in range(f_vs.shape[0]):
        line = 'f'
        for n in range(f_vs.shape[1]):
            v_id_str = str(f_vs[i][n])
            line += ' ' + v_id_str
        f.write(line + '\n')
    f.close()

def PCA(data, sort=True):
    X = np.array(data)  #维数为n*3，每一行表示一个点，每一列表示x、y、z

    # 标准化零平均值
    mu = np.mean(X, axis=0)   #axis=0压缩列 mu为1行*3列
    X_normalized = X - mu

    # 获得以列与列之间作为变量的协方差矩阵，即H的维数是3*3的
    H=np.cov(X_normalized,rowvar=False)
    # 获得特征值和特征向量，注意这里特征值并不是有序的
    eigenvalues, eigenvectors = np.linalg.eig(H)

    if sort:
        # argsort函数返回的是数组值从小到大的索引值，[::-1]表示从大到小排列
        sort = eigenvalues.argsort()
        eigenvalues = eigenvalues[sort]
        eigenvectors = eigenvectors[:, sort]
    #返回的是排序好的特征值以及对应的特征向量，特征值按照从小到大排列
    return eigenvalues, eigenvectors




